
# 1 "PR23.c"

# 19 "C:\Program Files (x86)\HI-TECH Software\PICC\9.80\include\pic168xa.h"
volatile unsigned char INDF @ 0x00;
volatile unsigned char TMR0 @ 0x01;
volatile unsigned char PCL @ 0x02;
volatile unsigned char STATUS @ 0x03;
volatile unsigned char FSR @ 0x04;
volatile unsigned char PORTA @ 0x05;
volatile unsigned char PORTB @ 0x06;
volatile unsigned char PORTC @ 0x07;

volatile unsigned char PORTD @ 0x08;
volatile unsigned char PORTE @ 0x09;

volatile unsigned char PCLATH @ 0x0A;
volatile unsigned char INTCON @ 0x0B;
volatile unsigned char PIR1 @ 0x0C;
volatile unsigned char PIR2 @ 0x0D;
volatile unsigned char TMR1L @ 0x0E;
volatile unsigned char TMR1H @ 0x0F;
volatile unsigned char T1CON @ 0x10;
volatile unsigned char TMR2 @ 0x11;
volatile unsigned char T2CON @ 0x12;
volatile unsigned char SSPBUF @ 0x13;
volatile unsigned char SSPCON @ 0x14;
volatile unsigned char CCPR1L @ 0x15;
volatile unsigned char CCPR1H @ 0x16;
volatile unsigned char CCP1CON @ 0x17;
volatile unsigned char RCSTA @ 0x18;
volatile unsigned char TXREG @ 0x19;
volatile unsigned char RCREG @ 0x1A;
volatile unsigned char CCPR2L @ 0x1B;
volatile unsigned char CCPR2H @ 0x1C;
volatile unsigned char CCP2CON @ 0x1D;
volatile unsigned char ADRESH @ 0x1E;
volatile unsigned char ADCON0 @ 0x1F;


volatile unsigned char OPTION @ 0x81;
volatile unsigned char TRISA @ 0x85;
volatile unsigned char TRISB @ 0x86;
volatile unsigned char TRISC @ 0x87;

volatile unsigned char TRISD @ 0x88;
volatile unsigned char TRISE @ 0x89;

volatile unsigned char PIE1 @ 0x8C;
volatile unsigned char PIE2 @ 0x8D;
volatile unsigned char PCON @ 0x8E;
volatile unsigned char SSPCON2 @ 0x91;
volatile unsigned char PR2 @ 0x92;
volatile unsigned char SSPADD @ 0x93;
volatile unsigned char SSPSTAT @ 0x94;
volatile unsigned char TXSTA @ 0x98;
volatile unsigned char SPBRG @ 0x99;
volatile unsigned char CMCON @ 0x9C;
volatile unsigned char CVRCON @ 0x9D;
volatile unsigned char ADRESL @ 0x9E;
volatile unsigned char ADCON1 @ 0x9F;


volatile unsigned char EEDATA @ 0x10C;
volatile unsigned char EEADR @ 0x10D;

volatile unsigned char EEADRL @ 0x10D;
volatile unsigned char EEDATH @ 0x10E;
volatile unsigned char EEADRH @ 0x10F;


volatile unsigned char EECON1 @ 0x18C;
volatile unsigned char EECON2 @ 0x18D;


volatile bit IRP @ (unsigned)&STATUS*8+7;
volatile bit RP1 @ (unsigned)&STATUS*8+6;
volatile bit RP0 @ (unsigned)&STATUS*8+5;
volatile bit TO @ (unsigned)&STATUS*8+4;
volatile bit PD @ (unsigned)&STATUS*8+3;
volatile bit ZERO @ (unsigned)&STATUS*8+2;
volatile bit DC @ (unsigned)&STATUS*8+1;
volatile bit CARRY @ (unsigned)&STATUS*8+0;


volatile bit RA5 @ (unsigned)&PORTA*8+5;
volatile bit RA4 @ (unsigned)&PORTA*8+4;
volatile bit RA3 @ (unsigned)&PORTA*8+3;
volatile bit RA2 @ (unsigned)&PORTA*8+2;
volatile bit RA1 @ (unsigned)&PORTA*8+1;
volatile bit RA0 @ (unsigned)&PORTA*8+0;


volatile bit RB7 @ (unsigned)&PORTB*8+7;
volatile bit RB6 @ (unsigned)&PORTB*8+6;
volatile bit RB5 @ (unsigned)&PORTB*8+5;
volatile bit RB4 @ (unsigned)&PORTB*8+4;
volatile bit RB3 @ (unsigned)&PORTB*8+3;
volatile bit RB2 @ (unsigned)&PORTB*8+2;
volatile bit RB1 @ (unsigned)&PORTB*8+1;
volatile bit RB0 @ (unsigned)&PORTB*8+0;


volatile bit RC7 @ (unsigned)&PORTC*8+7;
volatile bit RC6 @ (unsigned)&PORTC*8+6;
volatile bit RC5 @ (unsigned)&PORTC*8+5;
volatile bit RC4 @ (unsigned)&PORTC*8+4;
volatile bit RC3 @ (unsigned)&PORTC*8+3;
volatile bit RC2 @ (unsigned)&PORTC*8+2;
volatile bit RC1 @ (unsigned)&PORTC*8+1;
volatile bit RC0 @ (unsigned)&PORTC*8+0;



volatile bit RD7 @ (unsigned)&PORTD*8+7;
volatile bit RD6 @ (unsigned)&PORTD*8+6;
volatile bit RD5 @ (unsigned)&PORTD*8+5;
volatile bit RD4 @ (unsigned)&PORTD*8+4;
volatile bit RD3 @ (unsigned)&PORTD*8+3;
volatile bit RD2 @ (unsigned)&PORTD*8+2;
volatile bit RD1 @ (unsigned)&PORTD*8+1;
volatile bit RD0 @ (unsigned)&PORTD*8+0;


volatile bit RE2 @ (unsigned)&PORTE*8+2;
volatile bit RE1 @ (unsigned)&PORTE*8+1;
volatile bit RE0 @ (unsigned)&PORTE*8+0;



volatile bit GIE @ (unsigned)&INTCON*8+7;
volatile bit PEIE @ (unsigned)&INTCON*8+6;
volatile bit T0IE @ (unsigned)&INTCON*8+5;
volatile bit INTE @ (unsigned)&INTCON*8+4;
volatile bit RBIE @ (unsigned)&INTCON*8+3;
volatile bit T0IF @ (unsigned)&INTCON*8+2;
volatile bit INTF @ (unsigned)&INTCON*8+1;
volatile bit RBIF @ (unsigned)&INTCON*8+0;

volatile bit TMR0IE @ (unsigned)&INTCON*8+5;
volatile bit TMR0IF @ (unsigned)&INTCON*8+2;



volatile bit PSPIF @ (unsigned)&PIR1*8+7;

volatile bit ADIF @ (unsigned)&PIR1*8+6;
volatile bit RCIF @ (unsigned)&PIR1*8+5;
volatile bit TXIF @ (unsigned)&PIR1*8+4;
volatile bit SSPIF @ (unsigned)&PIR1*8+3;
volatile bit CCP1IF @ (unsigned)&PIR1*8+2;
volatile bit TMR2IF @ (unsigned)&PIR1*8+1;
volatile bit TMR1IF @ (unsigned)&PIR1*8+0;


volatile bit CMIF @ (unsigned)&PIR2*8+6;
volatile bit EEIF @ (unsigned)&PIR2*8+4;
volatile bit BCLIF @ (unsigned)&PIR2*8+3;
volatile bit CCP2IF @ (unsigned)&PIR2*8+0;


volatile bit T1CKPS1 @ (unsigned)&T1CON*8+5;
volatile bit T1CKPS0 @ (unsigned)&T1CON*8+4;
volatile bit T1OSCEN @ (unsigned)&T1CON*8+3;
volatile bit T1SYNC @ (unsigned)&T1CON*8+2;
volatile bit TMR1CS @ (unsigned)&T1CON*8+1;
volatile bit TMR1ON @ (unsigned)&T1CON*8+0;


volatile bit TOUTPS3 @ (unsigned)&T2CON*8+6;
volatile bit TOUTPS2 @ (unsigned)&T2CON*8+5;
volatile bit TOUTPS1 @ (unsigned)&T2CON*8+4;
volatile bit TOUTPS0 @ (unsigned)&T2CON*8+3;
volatile bit TMR2ON @ (unsigned)&T2CON*8+2;
volatile bit T2CKPS1 @ (unsigned)&T2CON*8+1;
volatile bit T2CKPS0 @ (unsigned)&T2CON*8+0;


volatile bit WCOL @ (unsigned)&SSPCON*8+7;
volatile bit SSPOV @ (unsigned)&SSPCON*8+6;
volatile bit SSPEN @ (unsigned)&SSPCON*8+5;
volatile bit CKP @ (unsigned)&SSPCON*8+4;
volatile bit SSPM3 @ (unsigned)&SSPCON*8+3;
volatile bit SSPM2 @ (unsigned)&SSPCON*8+2;
volatile bit SSPM1 @ (unsigned)&SSPCON*8+1;
volatile bit SSPM0 @ (unsigned)&SSPCON*8+0;


volatile bit CCP1X @ (unsigned)&CCP1CON*8+5;
volatile bit CCP1Y @ (unsigned)&CCP1CON*8+4;
volatile bit CCP1M3 @ (unsigned)&CCP1CON*8+3;
volatile bit CCP1M2 @ (unsigned)&CCP1CON*8+2;
volatile bit CCP1M1 @ (unsigned)&CCP1CON*8+1;
volatile bit CCP1M0 @ (unsigned)&CCP1CON*8+0;


volatile bit SPEN @ (unsigned)&RCSTA*8+7;
volatile bit RX9 @ (unsigned)&RCSTA*8+6;
volatile bit SREN @ (unsigned)&RCSTA*8+5;
volatile bit CREN @ (unsigned)&RCSTA*8+4;
volatile bit ADDEN @ (unsigned)&RCSTA*8+3;
volatile bit FERR @ (unsigned)&RCSTA*8+2;
volatile bit OERR @ (unsigned)&RCSTA*8+1;
volatile bit RX9D @ (unsigned)&RCSTA*8+0;


volatile bit CCP2X @ (unsigned)&CCP2CON*8+5;
volatile bit CCP2Y @ (unsigned)&CCP2CON*8+4;
volatile bit CCP2M3 @ (unsigned)&CCP2CON*8+3;
volatile bit CCP2M2 @ (unsigned)&CCP2CON*8+2;
volatile bit CCP2M1 @ (unsigned)&CCP2CON*8+1;
volatile bit CCP2M0 @ (unsigned)&CCP2CON*8+0;


volatile bit ADCS1 @ (unsigned)&ADCON0*8+7;
volatile bit ADCS0 @ (unsigned)&ADCON0*8+6;
volatile bit CHS2 @ (unsigned)&ADCON0*8+5;
volatile bit CHS1 @ (unsigned)&ADCON0*8+4;
volatile bit CHS0 @ (unsigned)&ADCON0*8+3;
volatile bit ADGO @ (unsigned)&ADCON0*8+2;

volatile bit GODONE @ (unsigned)&ADCON0*8+2;
volatile bit ADON @ (unsigned)&ADCON0*8+0;


volatile bit RBPU @ (unsigned)&OPTION*8+7;
volatile bit INTEDG @ (unsigned)&OPTION*8+6;
volatile bit T0CS @ (unsigned)&OPTION*8+5;
volatile bit T0SE @ (unsigned)&OPTION*8+4;
volatile bit PSA @ (unsigned)&OPTION*8+3;
volatile bit PS2 @ (unsigned)&OPTION*8+2;
volatile bit PS1 @ (unsigned)&OPTION*8+1;
volatile bit PS0 @ (unsigned)&OPTION*8+0;


volatile bit TRISA5 @ (unsigned)&TRISA*8+5;
volatile bit TRISA4 @ (unsigned)&TRISA*8+4;
volatile bit TRISA3 @ (unsigned)&TRISA*8+3;
volatile bit TRISA2 @ (unsigned)&TRISA*8+2;
volatile bit TRISA1 @ (unsigned)&TRISA*8+1;
volatile bit TRISA0 @ (unsigned)&TRISA*8+0;


volatile bit TRISB7 @ (unsigned)&TRISB*8+7;
volatile bit TRISB6 @ (unsigned)&TRISB*8+6;
volatile bit TRISB5 @ (unsigned)&TRISB*8+5;
volatile bit TRISB4 @ (unsigned)&TRISB*8+4;
volatile bit TRISB3 @ (unsigned)&TRISB*8+3;
volatile bit TRISB2 @ (unsigned)&TRISB*8+2;
volatile bit TRISB1 @ (unsigned)&TRISB*8+1;
volatile bit TRISB0 @ (unsigned)&TRISB*8+0;


volatile bit TRISC7 @ (unsigned)&TRISC*8+7;
volatile bit TRISC6 @ (unsigned)&TRISC*8+6;
volatile bit TRISC5 @ (unsigned)&TRISC*8+5;
volatile bit TRISC4 @ (unsigned)&TRISC*8+4;
volatile bit TRISC3 @ (unsigned)&TRISC*8+3;
volatile bit TRISC2 @ (unsigned)&TRISC*8+2;
volatile bit TRISC1 @ (unsigned)&TRISC*8+1;
volatile bit TRISC0 @ (unsigned)&TRISC*8+0;



volatile bit TRISD7 @ (unsigned)&TRISD*8+7;
volatile bit TRISD6 @ (unsigned)&TRISD*8+6;
volatile bit TRISD5 @ (unsigned)&TRISD*8+5;
volatile bit TRISD4 @ (unsigned)&TRISD*8+4;
volatile bit TRISD3 @ (unsigned)&TRISD*8+3;
volatile bit TRISD2 @ (unsigned)&TRISD*8+2;
volatile bit TRISD1 @ (unsigned)&TRISD*8+1;
volatile bit TRISD0 @ (unsigned)&TRISD*8+0;


volatile bit IBF @ (unsigned)&TRISE*8+7;
volatile bit OBF @ (unsigned)&TRISE*8+6;
volatile bit IBOV @ (unsigned)&TRISE*8+5;
volatile bit PSPMODE @ (unsigned)&TRISE*8+4;

volatile bit TRISE2 @ (unsigned)&TRISE*8+2;
volatile bit TRISE1 @ (unsigned)&TRISE*8+1;
volatile bit TRISE0 @ (unsigned)&TRISE*8+0;




volatile bit PSPIE @ (unsigned)&PIE1*8+7;

volatile bit ADIE @ (unsigned)&PIE1*8+6;
volatile bit RCIE @ (unsigned)&PIE1*8+5;
volatile bit TXIE @ (unsigned)&PIE1*8+4;
volatile bit SSPIE @ (unsigned)&PIE1*8+3;
volatile bit CCP1IE @ (unsigned)&PIE1*8+2;
volatile bit TMR2IE @ (unsigned)&PIE1*8+1;
volatile bit TMR1IE @ (unsigned)&PIE1*8+0;


volatile bit CMIE @ (unsigned)&PIE2*8+6;
volatile bit EEIE @ (unsigned)&PIE2*8+4;
volatile bit BCLIE @ (unsigned)&PIE2*8+3;
volatile bit CCP2IE @ (unsigned)&PIE2*8+0;


volatile bit POR @ (unsigned)&PCON*8+1;
volatile bit BOR @ (unsigned)&PCON*8+0;


volatile bit GCEN @ (unsigned)&SSPCON2*8+7;
volatile bit ACKSTAT @ (unsigned)&SSPCON2*8+6;
volatile bit ACKDT @ (unsigned)&SSPCON2*8+5;
volatile bit ACKEN @ (unsigned)&SSPCON2*8+4;
volatile bit RCEN @ (unsigned)&SSPCON2*8+3;
volatile bit PEN @ (unsigned)&SSPCON2*8+2;
volatile bit RSEN @ (unsigned)&SSPCON2*8+1;
volatile bit SEN @ (unsigned)&SSPCON2*8+0;


volatile bit SMP @ (unsigned)&SSPSTAT*8+7;
volatile bit CKE @ (unsigned)&SSPSTAT*8+6;
volatile bit DA @ (unsigned)&SSPSTAT*8+5;
volatile bit STOP @ (unsigned)&SSPSTAT*8+4;
volatile bit START @ (unsigned)&SSPSTAT*8+3;
volatile bit RW @ (unsigned)&SSPSTAT*8+2;
volatile bit UA @ (unsigned)&SSPSTAT*8+1;
volatile bit BF @ (unsigned)&SSPSTAT*8+0;

# 352
volatile bit CSRC @ (unsigned)&TXSTA*8+7;
volatile bit TX9 @ (unsigned)&TXSTA*8+6;
volatile bit TXEN @ (unsigned)&TXSTA*8+5;
volatile bit SYNC @ (unsigned)&TXSTA*8+4;
volatile bit BRGH @ (unsigned)&TXSTA*8+2;
volatile bit TRMT @ (unsigned)&TXSTA*8+1;
volatile bit TX9D @ (unsigned)&TXSTA*8+0;


volatile bit C2OUT @ (unsigned)&CMCON*8+7;
volatile bit C1OUT @ (unsigned)&CMCON*8+6;
volatile bit C2INV @ (unsigned)&CMCON*8+5;
volatile bit C1INV @ (unsigned)&CMCON*8+4;
volatile bit CIS @ (unsigned)&CMCON*8+3;
volatile bit CM2 @ (unsigned)&CMCON*8+2;
volatile bit CM1 @ (unsigned)&CMCON*8+1;
volatile bit CM0 @ (unsigned)&CMCON*8+0;


volatile bit CVREN @ (unsigned)&CVRCON*8+7;
volatile bit CVROE @ (unsigned)&CVRCON*8+6;
volatile bit CVRR @ (unsigned)&CVRCON*8+5;
volatile bit CVR3 @ (unsigned)&CVRCON*8+3;
volatile bit CVR2 @ (unsigned)&CVRCON*8+2;
volatile bit CVR1 @ (unsigned)&CVRCON*8+1;
volatile bit CVR0 @ (unsigned)&CVRCON*8+0;


volatile bit ADFM @ (unsigned)&ADCON1*8+7;
volatile bit ADCS2 @ (unsigned)&ADCON1*8+6;
volatile bit PCFG3 @ (unsigned)&ADCON1*8+3;
volatile bit PCFG2 @ (unsigned)&ADCON1*8+2;
volatile bit PCFG1 @ (unsigned)&ADCON1*8+1;
volatile bit PCFG0 @ (unsigned)&ADCON1*8+0;


volatile bit EEPGD @ (unsigned)&EECON1*8+7;
volatile bit WRERR @ (unsigned)&EECON1*8+3;
volatile bit WREN @ (unsigned)&EECON1*8+2;
volatile bit WR @ (unsigned)&EECON1*8+1;
volatile bit RD @ (unsigned)&EECON1*8+0;


# 503 "C:\Program Files (x86)\HI-TECH Software\PICC\9.80\include\pic.h"
#pragma inline(_nop)
extern void _nop(void);

# 556
extern unsigned int flash_read(unsigned short addr);

# 41 "C:\Program Files (x86)\HI-TECH Software\PICC\9.80\include\eeprom_routines.h"
extern void eeprom_write(unsigned char addr, unsigned char value);
extern unsigned char eeprom_read(unsigned char addr);


# 629 "C:\Program Files (x86)\HI-TECH Software\PICC\9.80\include\pic.h"
#pragma inline(_delay)
extern void _delay(unsigned long);

# 16 "PR23.c"
asm("\tpsect config,class=CONFIG,delta=2"); asm("\tdw ""0x3F32");

# 93
unsigned char data[6] = {0};
const unsigned char line [] = {"1.LINE FOLLOW"};
const unsigned char US[] = {"2.Ultrasonic"};
const unsigned char AS[] = {"3.Analog Sensor"};
const unsigned char XB[] = {"4.SKXBEE"};
const unsigned char SKPS[] = {"5.SKPS"};
const unsigned char *mode [5] = {&line[0],&US[0],&AS[0],&XB[0],&SKPS[0]};

unsigned int result;
unsigned int To=0,T=0,TH=0;
unsigned char REC;
unsigned char i=0,raw;

unsigned int us_value (unsigned char mode);



void init(void);
void delay(unsigned long data);
void delay_ms(unsigned long data);
void beep(unsigned char count);
void send_config(unsigned char data);
void send_char(unsigned char data);
void e_pulse(void);
void lcd_goto(unsigned char data);
void lcd_clr(void);
void send_string(const char *s);
void dis_num(unsigned long data);


void line_follow(void);
void ultrasonic(void);
void wireless_xbee(void);
void analog_sen(void);
void SKPS_PScon(void);


void forward(void);
void stop (void);
void backward (void);
void reverse (void);
void left(void);
void right(void);


void uart_send(unsigned char data);
unsigned char uart_rec(void);
unsigned char skps(unsigned char data);
void skps_vibrate(unsigned char motor, unsigned char value);


void read_adc(char config);



static void interrupt isr(void)
{
if (TMR0IF)
{
TMR0IF = 0;
To +=0x100;
}

if(RBIF)
{
RBIF = 0;
if (RB4)
{
TMR0 = 0;
To = 0;
}
else TH = TMR0 + To;
}

if(RCIF)
{
RCIF = 0;

if (RCREG == 'R') data[i=0]= RCREG;
else if (RCREG == 100) data[i=0]= RCREG;
if ((data[0] == 'R'))data [i++] = RCREG;
if (i>4) i = 4;
}
}




void main(void)
{

unsigned char m=0,i =0;
init();
beep(2);
RB5 = 1;
lcd_clr();
send_string("Select mode");
lcd_goto(20);
send_string(mode[m]);
RE2 = 0;

while(1)
{
if( !RE0)
{
while(!RE0);
m++;
if ( m > 4) m = 0;
lcd_goto(20);
send_string(mode[m]);
send_string("       ");
}

if (!RE1)
{
while(!RE1);
switch(m)
{
case 0 :
line_follow();
break;
case 1 :
ultrasonic();
break;
case 2 :
analog_sen();
break;
case 3 :
wireless_xbee();
break;
case 4 :
SKPS_PScon();
break;
default : ;
}
}
}
}



void delay(unsigned long data)
{
for( ;data>0;data-=1);
}


void delay_ms(unsigned long data)
{
while(data -- > 0)
_delay((unsigned long)((1)*(2000000/4000.0)));
}

void beep(unsigned char count)
{
while(count-- > 0)
{
RE2 = 1;
delay_ms(450);
RE2 = 0;
delay_ms(300);
}
}




void send_config(unsigned char data)
{
RB7 = 0;
PORTD = data;
delay_ms(2);
e_pulse();
}

void send_char(unsigned char data)
{
RB7 = 1;
PORTD = data;
delay_ms(2);
e_pulse();
}

void e_pulse(void)
{
RB6 = 1;
delay_ms(1);
RB6 = 0;
delay_ms(2);
}

void lcd_goto(unsigned char data)
{
if(data<16)
{
send_config(0x80+data);
}
else
{
data=data-20;
send_config(0xc0+data);
}


}

void lcd_clr(void)
{
send_config(0x01);
delay_ms(10);
}

void send_string(const char *s)
{
while (s && *s)send_char (*s++);
}

void dis_num(unsigned long data)
{
unsigned char hundred_thousand;
unsigned char ten_thousand;
unsigned char thousand;
unsigned char hundred;
unsigned char tenth;

hundred_thousand = data/100000;
data = data % 100000;
ten_thousand = data/10000;
data = data % 10000;
thousand = data / 1000;
data = data % 1000;
hundred = data / 100;
data = data % 100;
tenth = data / 10;
data = data % 10;

send_char(hundred_thousand + 0x30);
send_char(ten_thousand + 0x30);
send_char(thousand + 0x30);
send_char(hundred + 0x30);
send_char(tenth + 0x30);
send_char(data + 0x30);
}




void uart_send(unsigned char data)
{
while(TXIF==0);
TXREG=data;
}

unsigned char uart_rec(void)
{
unsigned char temp;
while(RCIF==0);
temp=RCREG;
return temp;
}




unsigned char skps(unsigned char data)
{
uart_send(data);
return uart_rec();
}

void skps_vibrate(unsigned char motor, unsigned char value)
{
uart_send(motor);
uart_send(value);
}

# 373
void init()
{
PORTA = 0;
PORTB = 0;
PORTC = 0;
PORTD = 0;
PORTE = 0;


TRISA = 0b00110011;

TRISB = 0b00011111;
TRISC = 0b10000000;
TRISD = 0b00000000;
TRISE = 0b00000011;
delay_ms(10);

ADCON1 = 0b10000100;



RBIE = 1;


PR2 = 255;
T2CON = 0b00000100;
CCP1CON = 0b00001100;
CCP2CON = 0b00001100;


T0CS = 0;
PSA = 0;
PS2 = 1;
PS1 = 1;
PS0 = 1;
TMR0IE = 1;
TMR0 = 0;


SPBRG = 0x81;
BRGH = 1;
TXEN = 1;
TX9 = 0;
CREN = 1;
SPEN = 1;
RX9 = 0;
RCIE = 1;


GIE = 1;
PEIE = 1;


RB6 = 1;
delay_ms(15);
send_config(0b00111000);
send_config(0b00000110);
send_config(0b00001100);
send_config(0b00000001);
delay_ms(5);

RA2 = 1;
RB5 = 0;
RE2 = 0;
stop();
}

# 447
void line_follow()
{
unsigned char memory = 0;

lcd_clr();
send_string("Position");


while(1)
{
if ((RB0==1)&&(RB1==0)&&(RB2==0)&&(RB3==0))
{ forward();
CCPR1L = 0;
CCPR2L = 255;
memory = PORTB&0b00001111;
lcd_goto(20);
send_string ("right  ");
}
else if ((RB0==1)&&(RB1==1)&&(RB2==0)&&(RB3==0))
{ forward();
CCPR1L = 180;
CCPR2L = 255;
memory = PORTB&0b00001111;
lcd_goto(20);
send_string ("m_right2");
}
else if ((RB0==0)&&(RB1==1)&&(RB2==0)&&(RB3==0))
{ forward();
CCPR1L = 200;
CCPR2L = 255;
memory = PORTB&0b00001111;
lcd_goto(20);
send_string ("m_right1  ");
}
else if ((RB0==1)&&(RB1==1)&&(RB2==1)&&(RB3==0))
{
forward();
CCPR1L = 200;
CCPR2L = 255;
memory = PORTB&0b00001111;
lcd_goto(20);
send_string ("m_right1  ");
}
else if ((RB0==0)&&(RB1==1)&&(RB2==1)&&(RB3==0))
{
forward();
CCPR1L = 255;
CCPR2L = 255;
memory = PORTB&0b00001111;
lcd_goto(20);
send_string ("middle ");
}
else if ((RB0==0)&&(RB1==0)&&(RB2==1)&&(RB3==0))
{
forward();
CCPR1L = 255;
CCPR2L = 200;
memory = PORTB&0b00001111;
lcd_goto(20);
send_string ("m_left1   ");
}
else if ((RB0==0)&&(RB1==1)&&(RB2==1)&&(RB3==1))
{
forward();
CCPR1L = 255;
CCPR2L = 200;
memory = PORTB&0b00001111;
lcd_goto(20);
send_string ("m_left1   ");
}
else if ((RB0==0)&&(RB1==0)&&(RB2==1)&&(RB3==1))
{
forward();
CCPR1L = 255;
CCPR2L = 180;
memory = PORTB&0b00001111;
lcd_goto(20);
send_string ("m_left2 ");
}
else if ((RB0==0)&&(RB1==0)&&(RB2==0)&&(RB3==1))
{
forward();
CCPR1L = 255;
CCPR2L = 0;
memory = PORTB&0b00001111;
lcd_goto(20);
send_string ("left   ");
}
else if ((RB0==0)&&(RB1==0)&&(RB2==0)&&(RB3==0))
{
forward();
if ((memory == 0b00000001)||(memory == 0b00000011)||(memory == 0b0000010)||(memory == 0b0000111))
{
CCPR1L = 0;
CCPR2L = 255;
}
else if ((memory == 0b00001000)||(memory == 0b0000100)||(memory == 0b00001100)||(memory == 0b0001110))
{
CCPR1L = 255;
CCPR2L = 0;
}
}
else if ((RB0==1)&&(RB1==1)&&(RB2==1)&&(RB3==1))
{
forward();
}
}
}

# 560
void ultrasonic(void)
{
int distance;
char n=1;
lcd_clr();
send_string("Measure mode");
lcd_goto(20);
send_string("ADC");

while(1)
{
if(!RE0)
{
while(!RE0);
n++;
lcd_goto(20);
switch (n)
{
case 2 :send_string("PWM ");
break;
case 3 :send_string("UART");
break;
default:send_string("ADC ");
n = 1;
}
}

if (!RE1)
{
while(!RE1);
break;
}
}
lcd_clr();
send_string("Distance");

while(1)
{
lcd_goto(20);
distance = us_value(n);
dis_num(distance);

if (distance> 40)
{
forward();
CCPR1L = 255;
CCPR2L = 255;
RE2 = 0;
}
else if (distance> 30)
{
forward();
CCPR1L = 230;
CCPR2L = 230;
RE2 = 0;
}
else if( distance >20)
{
stop();
RE2 = 0;
}
else
{
backward();
CCPR1L = 230;
CCPR2L = 230;
RE2 = 1;
}
}
}

# 635
void analog_sen(void)
{
int distance;
lcd_clr();
send_string("Distance");

while(1)
{
lcd_goto(20);
read_adc(0b10001001);
distance = result;
dis_num(result);

if (distance< 200)
{
backward();
CCPR1L = 255;
CCPR2L = 255;
RE2 = 0;
}
else if (distance< 250)
{
backward();
CCPR1L = 230;
CCPR2L = 230;
RE2 = 0;
}
else if( distance < 300)
{
stop();
RE2 = 0;
}
else
{
forward();
CCPR1L = 230;
CCPR2L = 230;
RE2 = 1;
}
}
}

# 681
void wireless_xbee (void)
{
lcd_clr();
while(1)
{
lcd_goto (0);
if (data[0] == 100)
{
send_string("  XBEE CONTROL  ");
CCPR1L = 200;
CCPR2L = 200;
while(1)
{
lcd_goto(20);
if (RCREG == '8')
{
forward();
send_string("FORWARD        ");
}

else if (RCREG == '2')
{
backward();
send_string("BACKWARD        ");
}
else if (RCREG == '6')
{
right();
send_string("TURN RIGHT      ");
}

else if (RCREG == '4')
{
left();
send_string("TURN LEFT       ");
}

else if (RCREG == '5')
{
stop();
send_string("INVALID COMMAND  ");
}

else
{
stop();
send_string("INVALID COMMAND  ");
}
}
}
else send_string("COMMAND");
}
}

# 739
void SKPS_PScon()
{
unsigned char up_v, down_v, left_v, right_v;


RCIE = 0;
GIE = 0;
PEIE = 0;
TMR0IE = 0;

stop();

lcd_clr();
lcd_goto(0);
send_string("Controlling PR23");
lcd_goto(20);
send_string("   Using SKPS");

while(1)
{

if(skps(10)==0)RE2=1;
else RE2=0;


up_v=skps(24);
down_v=skps(25);
left_v=skps(22);
right_v=skps(23);


if(skps(4)==0)
{
forward();
CCPR1L=230;
CCPR2L=230;
}
else if(skps(6)==0)
{
backward();
CCPR1L=230;
CCPR2L=230;
}
else if(skps(7)==0)
{
left();
CCPR1L=230;
CCPR2L=230;
}
else if(skps(5)==0)
{
right();
CCPR1L=230;
CCPR2L=230;
}


else if(up_v>0)
{
forward();
if(left_v>0)
{
if(up_v>left_v)CCPR1L=up_v-left_v+140;
else CCPR1L=140;
CCPR2L=up_v+140;
}
else if(right_v>0)
{
if(up_v>right_v)CCPR2L=up_v-right_v+140;
else CCPR2L=140;
CCPR1L=up_v+140;
}
else
{
CCPR1L=up_v+140;
CCPR2L=up_v+140;
}
}
else if(down_v>0)
{
backward();
if(left_v>0)
{
if(down_v>left_v)CCPR2L=down_v-left_v+140;
else CCPR2L=140;
CCPR1L=down_v+140;
}
else if(right_v>0)
{
if(down_v>right_v)CCPR1L=down_v-right_v+140;
else CCPR1L=140;
CCPR2L=down_v+140;
}
else
{
CCPR1L=down_v+140;
CCPR2L=down_v+140;
}
}
else if(left_v>0)
{
left();
CCPR1L=left_v+120;
CCPR2L=left_v+120;
}
else if(right_v>0)
{
right();
CCPR1L=right_v+120;
CCPR2L=right_v+120;
}
else
{
stop();
CCPR1L=255;
CCPR2L=255;
}
}
}

# 866
unsigned int us_value (unsigned char mode)
{
unsigned int value;
switch (mode)
{
case 1:
read_adc(0b10000001);
value = result;
break;
case 2:
value = TH;
break;
case 3: if ( data [0]=='R')
{
value = (data[1] - 0x30)*100+ (data[2] - 0x30)*10+ (data[3] - 0x30);
}
else
{
lcd_goto(20);
send_string("not connected");
while(1);
}
default: ;
}
return value;
}

# 899
void read_adc(char config)
{
unsigned short i;
unsigned long result_temp=0;

ADCON0 = config;
delay(10000);
for(i=200;i>0;i-=1)
{
ADGO = 1;
while(ADGO==1);
result=ADRESH;
result=result<<8;
result=result|ADRESL;

result_temp+=result;
}
result = result_temp/200;
ADON = 0;
}

# 925
void forward ()
{
RC0 = 0;
RC3 = 1;
RC4 = 0;
RC5 = 1;
}

void backward ()
{
RC0 = 1;
RC3 = 0;
RC4 = 1;
RC5 = 0;
}

void left()
{
RC4 = 1;
RC5 = 0;
RC0 = 0;
RC3 = 1;
}
void right()
{
RC4 = 0;
RC5 = 1;
RC0 = 1;
RC3 = 0;
}

void stop()
{
RC4 = 1;
RC5 = 1;
RC0 = 1;
RC3 = 1;
}
